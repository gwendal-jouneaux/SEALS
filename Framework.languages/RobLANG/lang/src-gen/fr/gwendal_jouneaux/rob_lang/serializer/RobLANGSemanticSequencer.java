/*
 * generated by Xtext 2.22.0
 */
package fr.gwendal_jouneaux.rob_lang.serializer;

import com.google.inject.Inject;
import fr.gwendal_jouneaux.rob_lang.robLANG.And;
import fr.gwendal_jouneaux.rob_lang.robLANG.AnnotatedEffector;
import fr.gwendal_jouneaux.rob_lang.robLANG.ArrayAdd;
import fr.gwendal_jouneaux.rob_lang.robLANG.ArrayGet;
import fr.gwendal_jouneaux.rob_lang.robLANG.ArrayLength;
import fr.gwendal_jouneaux.rob_lang.robLANG.ArrayNew;
import fr.gwendal_jouneaux.rob_lang.robLANG.ArrayRemove;
import fr.gwendal_jouneaux.rob_lang.robLANG.ArraySet;
import fr.gwendal_jouneaux.rob_lang.robLANG.Assignment;
import fr.gwendal_jouneaux.rob_lang.robLANG.Block;
import fr.gwendal_jouneaux.rob_lang.robLANG.BoolConstant;
import fr.gwendal_jouneaux.rob_lang.robLANG.Break;
import fr.gwendal_jouneaux.rob_lang.robLANG.ComplexFunction;
import fr.gwendal_jouneaux.rob_lang.robLANG.Condition;
import fr.gwendal_jouneaux.rob_lang.robLANG.Divide;
import fr.gwendal_jouneaux.rob_lang.robLANG.DoubleConstant;
import fr.gwendal_jouneaux.rob_lang.robLANG.Equality;
import fr.gwendal_jouneaux.rob_lang.robLANG.FunCall;
import fr.gwendal_jouneaux.rob_lang.robLANG.FunParamCapture;
import fr.gwendal_jouneaux.rob_lang.robLANG.FunParamExp;
import fr.gwendal_jouneaux.rob_lang.robLANG.GetMaxSpeed;
import fr.gwendal_jouneaux.rob_lang.robLANG.Greater;
import fr.gwendal_jouneaux.rob_lang.robLANG.GreaterEq;
import fr.gwendal_jouneaux.rob_lang.robLANG.Inequality;
import fr.gwendal_jouneaux.rob_lang.robLANG.InlineFunction;
import fr.gwendal_jouneaux.rob_lang.robLANG.IntConstant;
import fr.gwendal_jouneaux.rob_lang.robLANG.Less;
import fr.gwendal_jouneaux.rob_lang.robLANG.LessEq;
import fr.gwendal_jouneaux.rob_lang.robLANG.Loop;
import fr.gwendal_jouneaux.rob_lang.robLANG.MathAbs;
import fr.gwendal_jouneaux.rob_lang.robLANG.MathCos;
import fr.gwendal_jouneaux.rob_lang.robLANG.MathModulo;
import fr.gwendal_jouneaux.rob_lang.robLANG.MathPow;
import fr.gwendal_jouneaux.rob_lang.robLANG.MathSin;
import fr.gwendal_jouneaux.rob_lang.robLANG.MathSqrt;
import fr.gwendal_jouneaux.rob_lang.robLANG.Minus;
import fr.gwendal_jouneaux.rob_lang.robLANG.MoveBackward;
import fr.gwendal_jouneaux.rob_lang.robLANG.MoveForward;
import fr.gwendal_jouneaux.rob_lang.robLANG.Multiply;
import fr.gwendal_jouneaux.rob_lang.robLANG.Not;
import fr.gwendal_jouneaux.rob_lang.robLANG.Or;
import fr.gwendal_jouneaux.rob_lang.robLANG.Plus;
import fr.gwendal_jouneaux.rob_lang.robLANG.PrintExpression;
import fr.gwendal_jouneaux.rob_lang.robLANG.Return;
import fr.gwendal_jouneaux.rob_lang.robLANG.RobLANGPackage;
import fr.gwendal_jouneaux.rob_lang.robLANG.Robot;
import fr.gwendal_jouneaux.rob_lang.robLANG.SenseBattery;
import fr.gwendal_jouneaux.rob_lang.robLANG.SenseCompass;
import fr.gwendal_jouneaux.rob_lang.robLANG.SenseDistance;
import fr.gwendal_jouneaux.rob_lang.robLANG.SensePosition;
import fr.gwendal_jouneaux.rob_lang.robLANG.SenseTime;
import fr.gwendal_jouneaux.rob_lang.robLANG.SetNominalSpeed;
import fr.gwendal_jouneaux.rob_lang.robLANG.StringConstant;
import fr.gwendal_jouneaux.rob_lang.robLANG.SymbolRef;
import fr.gwendal_jouneaux.rob_lang.robLANG.TurnLeft;
import fr.gwendal_jouneaux.rob_lang.robLANG.TurnRight;
import fr.gwendal_jouneaux.rob_lang.robLANG.Type;
import fr.gwendal_jouneaux.rob_lang.robLANG.Variable;
import fr.gwendal_jouneaux.rob_lang.services.RobLANGGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class RobLANGSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private RobLANGGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == RobLANGPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case RobLANGPackage.AND:
				sequence_And(context, (And) semanticObject); 
				return; 
			case RobLANGPackage.ANNOTATED_EFFECTOR:
				sequence_AnnotatedEffector(context, (AnnotatedEffector) semanticObject); 
				return; 
			case RobLANGPackage.ARRAY_ADD:
				sequence_ArrayAdd(context, (ArrayAdd) semanticObject); 
				return; 
			case RobLANGPackage.ARRAY_GET:
				sequence_ArrayGet(context, (ArrayGet) semanticObject); 
				return; 
			case RobLANGPackage.ARRAY_LENGTH:
				sequence_ArrayLength(context, (ArrayLength) semanticObject); 
				return; 
			case RobLANGPackage.ARRAY_NEW:
				sequence_ArrayNew(context, (ArrayNew) semanticObject); 
				return; 
			case RobLANGPackage.ARRAY_REMOVE:
				sequence_ArrayRemove(context, (ArrayRemove) semanticObject); 
				return; 
			case RobLANGPackage.ARRAY_SET:
				sequence_ArraySet(context, (ArraySet) semanticObject); 
				return; 
			case RobLANGPackage.ASSIGNMENT:
				sequence_Assignment(context, (Assignment) semanticObject); 
				return; 
			case RobLANGPackage.BLOCK:
				sequence_Block(context, (Block) semanticObject); 
				return; 
			case RobLANGPackage.BOOL_CONSTANT:
				sequence_Atomic(context, (BoolConstant) semanticObject); 
				return; 
			case RobLANGPackage.BREAK:
				sequence_Break(context, (Break) semanticObject); 
				return; 
			case RobLANGPackage.COMPLEX_FUNCTION:
				sequence_ComplexFunction(context, (ComplexFunction) semanticObject); 
				return; 
			case RobLANGPackage.CONDITION:
				sequence_Condition(context, (Condition) semanticObject); 
				return; 
			case RobLANGPackage.DIVIDE:
				sequence_MulOrDiv(context, (Divide) semanticObject); 
				return; 
			case RobLANGPackage.DOUBLE_CONSTANT:
				sequence_Atomic(context, (DoubleConstant) semanticObject); 
				return; 
			case RobLANGPackage.EQUALITY:
				sequence_Equality(context, (Equality) semanticObject); 
				return; 
			case RobLANGPackage.FUN_CALL:
				sequence_FunCall(context, (FunCall) semanticObject); 
				return; 
			case RobLANGPackage.FUN_PARAM_CAPTURE:
				sequence_FunParam(context, (FunParamCapture) semanticObject); 
				return; 
			case RobLANGPackage.FUN_PARAM_EXP:
				sequence_FunParam(context, (FunParamExp) semanticObject); 
				return; 
			case RobLANGPackage.GET_MAX_SPEED:
				sequence_GetMaxSpeed(context, (GetMaxSpeed) semanticObject); 
				return; 
			case RobLANGPackage.GREATER:
				sequence_Comparison(context, (Greater) semanticObject); 
				return; 
			case RobLANGPackage.GREATER_EQ:
				sequence_Comparison(context, (GreaterEq) semanticObject); 
				return; 
			case RobLANGPackage.INEQUALITY:
				sequence_Equality(context, (Inequality) semanticObject); 
				return; 
			case RobLANGPackage.INLINE_FUNCTION:
				sequence_InlineFunction(context, (InlineFunction) semanticObject); 
				return; 
			case RobLANGPackage.INT_CONSTANT:
				sequence_Atomic(context, (IntConstant) semanticObject); 
				return; 
			case RobLANGPackage.LESS:
				sequence_Comparison(context, (Less) semanticObject); 
				return; 
			case RobLANGPackage.LESS_EQ:
				sequence_Comparison(context, (LessEq) semanticObject); 
				return; 
			case RobLANGPackage.LOOP:
				sequence_Loop(context, (Loop) semanticObject); 
				return; 
			case RobLANGPackage.MATH_ABS:
				sequence_MathAbs(context, (MathAbs) semanticObject); 
				return; 
			case RobLANGPackage.MATH_COS:
				sequence_MathCos(context, (MathCos) semanticObject); 
				return; 
			case RobLANGPackage.MATH_MODULO:
				sequence_MathModulo(context, (MathModulo) semanticObject); 
				return; 
			case RobLANGPackage.MATH_POW:
				sequence_MathPow(context, (MathPow) semanticObject); 
				return; 
			case RobLANGPackage.MATH_SIN:
				sequence_MathSin(context, (MathSin) semanticObject); 
				return; 
			case RobLANGPackage.MATH_SQRT:
				sequence_MathSqrt(context, (MathSqrt) semanticObject); 
				return; 
			case RobLANGPackage.MINUS:
				sequence_PlusOrMinus(context, (Minus) semanticObject); 
				return; 
			case RobLANGPackage.MOVE_BACKWARD:
				sequence_MoveBackward(context, (MoveBackward) semanticObject); 
				return; 
			case RobLANGPackage.MOVE_FORWARD:
				sequence_MoveForward(context, (MoveForward) semanticObject); 
				return; 
			case RobLANGPackage.MULTIPLY:
				sequence_MulOrDiv(context, (Multiply) semanticObject); 
				return; 
			case RobLANGPackage.NOT:
				sequence_Primary(context, (Not) semanticObject); 
				return; 
			case RobLANGPackage.OR:
				sequence_Or(context, (Or) semanticObject); 
				return; 
			case RobLANGPackage.PARAMETER:
				sequence_Parameter(context, (fr.gwendal_jouneaux.rob_lang.robLANG.Parameter) semanticObject); 
				return; 
			case RobLANGPackage.PLUS:
				sequence_PlusOrMinus(context, (Plus) semanticObject); 
				return; 
			case RobLANGPackage.PRINT_EXPRESSION:
				sequence_PrintExpression(context, (PrintExpression) semanticObject); 
				return; 
			case RobLANGPackage.RETURN:
				sequence_Return(context, (Return) semanticObject); 
				return; 
			case RobLANGPackage.ROBOT:
				sequence_Robot(context, (Robot) semanticObject); 
				return; 
			case RobLANGPackage.SENSE_BATTERY:
				sequence_SenseBattery(context, (SenseBattery) semanticObject); 
				return; 
			case RobLANGPackage.SENSE_COMPASS:
				sequence_SenseCompass(context, (SenseCompass) semanticObject); 
				return; 
			case RobLANGPackage.SENSE_DISTANCE:
				sequence_SenseDistance(context, (SenseDistance) semanticObject); 
				return; 
			case RobLANGPackage.SENSE_POSITION:
				sequence_SensePosition(context, (SensePosition) semanticObject); 
				return; 
			case RobLANGPackage.SENSE_TIME:
				sequence_SenseTime(context, (SenseTime) semanticObject); 
				return; 
			case RobLANGPackage.SET_NOMINAL_SPEED:
				sequence_SetNominalSpeed(context, (SetNominalSpeed) semanticObject); 
				return; 
			case RobLANGPackage.STRING_CONSTANT:
				sequence_Atomic(context, (StringConstant) semanticObject); 
				return; 
			case RobLANGPackage.SYMBOL_REF:
				sequence_Atomic(context, (SymbolRef) semanticObject); 
				return; 
			case RobLANGPackage.TURN_LEFT:
				sequence_TurnLeft(context, (TurnLeft) semanticObject); 
				return; 
			case RobLANGPackage.TURN_RIGHT:
				sequence_TurnRight(context, (TurnRight) semanticObject); 
				return; 
			case RobLANGPackage.TYPE:
				sequence_Type(context, (Type) semanticObject); 
				return; 
			case RobLANGPackage.VARIABLE:
				sequence_Variable(context, (Variable) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Statement returns And
	 *     Expression returns And
	 *     Or returns And
	 *     Or.Or_1_0 returns And
	 *     And returns And
	 *     And.And_1_0 returns And
	 *     Equality returns And
	 *     Equality.Equality_1_0_0_0 returns And
	 *     Equality.Inequality_1_0_1_0 returns And
	 *     Comparison returns And
	 *     Comparison.GreaterEq_1_0_0_0 returns And
	 *     Comparison.LessEq_1_0_1_0 returns And
	 *     Comparison.Greater_1_0_2_0 returns And
	 *     Comparison.Less_1_0_3_0 returns And
	 *     PlusOrMinus returns And
	 *     PlusOrMinus.Plus_1_0_0_0 returns And
	 *     PlusOrMinus.Minus_1_0_1_0 returns And
	 *     MulOrDiv returns And
	 *     MulOrDiv.Multiply_1_0_0_0 returns And
	 *     MulOrDiv.Divide_1_0_1_0 returns And
	 *     Primary returns And
	 *
	 * Constraint:
	 *     (left=And_And_1_0 right=Equality)
	 */
	protected void sequence_And(ISerializationContext context, And semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobLANGPackage.Literals.AND__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANGPackage.Literals.AND__LEFT));
			if (transientValues.isValueTransient(semanticObject, RobLANGPackage.Literals.AND__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANGPackage.Literals.AND__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAndAccess().getAndLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAndAccess().getRightEqualityParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns AnnotatedEffector
	 *     Effector returns AnnotatedEffector
	 *     AnnotatedEffector returns AnnotatedEffector
	 *
	 * Constraint:
	 *     (
	 *         property=AdaptationProperty 
	 *         lowerBound=Expression 
	 *         higherBound=Expression 
	 *         (statement=MoveForward | statement=MoveBackward | statement=TurnLeft | statement=TurnRight)
	 *     )
	 */
	protected void sequence_AnnotatedEffector(ISerializationContext context, AnnotatedEffector semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ArrayAdd
	 *     ArrayStatement returns ArrayAdd
	 *     ArrayAdd returns ArrayAdd
	 *
	 * Constraint:
	 *     (array=Expression valueOrIndex=Expression indexedValue=Expression?)
	 */
	protected void sequence_ArrayAdd(ISerializationContext context, ArrayAdd semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ArrayGet
	 *     Expression returns ArrayGet
	 *     Or returns ArrayGet
	 *     Or.Or_1_0 returns ArrayGet
	 *     And returns ArrayGet
	 *     And.And_1_0 returns ArrayGet
	 *     Equality returns ArrayGet
	 *     Equality.Equality_1_0_0_0 returns ArrayGet
	 *     Equality.Inequality_1_0_1_0 returns ArrayGet
	 *     Comparison returns ArrayGet
	 *     Comparison.GreaterEq_1_0_0_0 returns ArrayGet
	 *     Comparison.LessEq_1_0_1_0 returns ArrayGet
	 *     Comparison.Greater_1_0_2_0 returns ArrayGet
	 *     Comparison.Less_1_0_3_0 returns ArrayGet
	 *     PlusOrMinus returns ArrayGet
	 *     PlusOrMinus.Plus_1_0_0_0 returns ArrayGet
	 *     PlusOrMinus.Minus_1_0_1_0 returns ArrayGet
	 *     MulOrDiv returns ArrayGet
	 *     MulOrDiv.Multiply_1_0_0_0 returns ArrayGet
	 *     MulOrDiv.Divide_1_0_1_0 returns ArrayGet
	 *     Primary returns ArrayGet
	 *     Atomic returns ArrayGet
	 *     ArrayExpression returns ArrayGet
	 *     ArrayGet returns ArrayGet
	 *
	 * Constraint:
	 *     (array=Expression index=Expression)
	 */
	protected void sequence_ArrayGet(ISerializationContext context, ArrayGet semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobLANGPackage.Literals.ARRAY_GET__ARRAY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANGPackage.Literals.ARRAY_GET__ARRAY));
			if (transientValues.isValueTransient(semanticObject, RobLANGPackage.Literals.ARRAY_GET__INDEX) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANGPackage.Literals.ARRAY_GET__INDEX));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getArrayGetAccess().getArrayExpressionParserRuleCall_1_0(), semanticObject.getArray());
		feeder.accept(grammarAccess.getArrayGetAccess().getIndexExpressionParserRuleCall_3_0(), semanticObject.getIndex());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ArrayLength
	 *     Expression returns ArrayLength
	 *     Or returns ArrayLength
	 *     Or.Or_1_0 returns ArrayLength
	 *     And returns ArrayLength
	 *     And.And_1_0 returns ArrayLength
	 *     Equality returns ArrayLength
	 *     Equality.Equality_1_0_0_0 returns ArrayLength
	 *     Equality.Inequality_1_0_1_0 returns ArrayLength
	 *     Comparison returns ArrayLength
	 *     Comparison.GreaterEq_1_0_0_0 returns ArrayLength
	 *     Comparison.LessEq_1_0_1_0 returns ArrayLength
	 *     Comparison.Greater_1_0_2_0 returns ArrayLength
	 *     Comparison.Less_1_0_3_0 returns ArrayLength
	 *     PlusOrMinus returns ArrayLength
	 *     PlusOrMinus.Plus_1_0_0_0 returns ArrayLength
	 *     PlusOrMinus.Minus_1_0_1_0 returns ArrayLength
	 *     MulOrDiv returns ArrayLength
	 *     MulOrDiv.Multiply_1_0_0_0 returns ArrayLength
	 *     MulOrDiv.Divide_1_0_1_0 returns ArrayLength
	 *     Primary returns ArrayLength
	 *     Atomic returns ArrayLength
	 *     ArrayExpression returns ArrayLength
	 *     ArrayLength returns ArrayLength
	 *
	 * Constraint:
	 *     array=Expression
	 */
	protected void sequence_ArrayLength(ISerializationContext context, ArrayLength semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobLANGPackage.Literals.ARRAY_LENGTH__ARRAY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANGPackage.Literals.ARRAY_LENGTH__ARRAY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getArrayLengthAccess().getArrayExpressionParserRuleCall_1_0(), semanticObject.getArray());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ArrayNew
	 *     Expression returns ArrayNew
	 *     Or returns ArrayNew
	 *     Or.Or_1_0 returns ArrayNew
	 *     And returns ArrayNew
	 *     And.And_1_0 returns ArrayNew
	 *     Equality returns ArrayNew
	 *     Equality.Equality_1_0_0_0 returns ArrayNew
	 *     Equality.Inequality_1_0_1_0 returns ArrayNew
	 *     Comparison returns ArrayNew
	 *     Comparison.GreaterEq_1_0_0_0 returns ArrayNew
	 *     Comparison.LessEq_1_0_1_0 returns ArrayNew
	 *     Comparison.Greater_1_0_2_0 returns ArrayNew
	 *     Comparison.Less_1_0_3_0 returns ArrayNew
	 *     PlusOrMinus returns ArrayNew
	 *     PlusOrMinus.Plus_1_0_0_0 returns ArrayNew
	 *     PlusOrMinus.Minus_1_0_1_0 returns ArrayNew
	 *     MulOrDiv returns ArrayNew
	 *     MulOrDiv.Multiply_1_0_0_0 returns ArrayNew
	 *     MulOrDiv.Divide_1_0_1_0 returns ArrayNew
	 *     Primary returns ArrayNew
	 *     Atomic returns ArrayNew
	 *     ArrayExpression returns ArrayNew
	 *     ArrayNew returns ArrayNew
	 *
	 * Constraint:
	 *     dimension=INT
	 */
	protected void sequence_ArrayNew(ISerializationContext context, ArrayNew semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobLANGPackage.Literals.ARRAY_NEW__DIMENSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANGPackage.Literals.ARRAY_NEW__DIMENSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getArrayNewAccess().getDimensionINTTerminalRuleCall_1_0(), semanticObject.getDimension());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ArrayRemove
	 *     ArrayStatement returns ArrayRemove
	 *     ArrayRemove returns ArrayRemove
	 *
	 * Constraint:
	 *     (array=Expression index=Expression)
	 */
	protected void sequence_ArrayRemove(ISerializationContext context, ArrayRemove semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobLANGPackage.Literals.ARRAY_STATEMENT__ARRAY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANGPackage.Literals.ARRAY_STATEMENT__ARRAY));
			if (transientValues.isValueTransient(semanticObject, RobLANGPackage.Literals.ARRAY_REMOVE__INDEX) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANGPackage.Literals.ARRAY_REMOVE__INDEX));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getArrayRemoveAccess().getArrayExpressionParserRuleCall_1_0(), semanticObject.getArray());
		feeder.accept(grammarAccess.getArrayRemoveAccess().getIndexExpressionParserRuleCall_3_0(), semanticObject.getIndex());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ArraySet
	 *     ArrayStatement returns ArraySet
	 *     ArraySet returns ArraySet
	 *
	 * Constraint:
	 *     (array=Expression index=Expression value=Expression)
	 */
	protected void sequence_ArraySet(ISerializationContext context, ArraySet semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobLANGPackage.Literals.ARRAY_STATEMENT__ARRAY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANGPackage.Literals.ARRAY_STATEMENT__ARRAY));
			if (transientValues.isValueTransient(semanticObject, RobLANGPackage.Literals.ARRAY_SET__INDEX) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANGPackage.Literals.ARRAY_SET__INDEX));
			if (transientValues.isValueTransient(semanticObject, RobLANGPackage.Literals.ARRAY_SET__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANGPackage.Literals.ARRAY_SET__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getArraySetAccess().getArrayExpressionParserRuleCall_1_0(), semanticObject.getArray());
		feeder.accept(grammarAccess.getArraySetAccess().getIndexExpressionParserRuleCall_3_0(), semanticObject.getIndex());
		feeder.accept(grammarAccess.getArraySetAccess().getValueExpressionParserRuleCall_5_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Assignment
	 *     Assignment returns Assignment
	 *
	 * Constraint:
	 *     (assignee=[Symbol|ID] expression=Expression)
	 */
	protected void sequence_Assignment(ISerializationContext context, Assignment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobLANGPackage.Literals.ASSIGNMENT__ASSIGNEE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANGPackage.Literals.ASSIGNMENT__ASSIGNEE));
			if (transientValues.isValueTransient(semanticObject, RobLANGPackage.Literals.ASSIGNMENT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANGPackage.Literals.ASSIGNMENT__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssignmentAccess().getAssigneeSymbolIDTerminalRuleCall_0_0_1(), semanticObject.eGet(RobLANGPackage.Literals.ASSIGNMENT__ASSIGNEE, false));
		feeder.accept(grammarAccess.getAssignmentAccess().getExpressionExpressionParserRuleCall_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns BoolConstant
	 *     Expression returns BoolConstant
	 *     Or returns BoolConstant
	 *     Or.Or_1_0 returns BoolConstant
	 *     And returns BoolConstant
	 *     And.And_1_0 returns BoolConstant
	 *     Equality returns BoolConstant
	 *     Equality.Equality_1_0_0_0 returns BoolConstant
	 *     Equality.Inequality_1_0_1_0 returns BoolConstant
	 *     Comparison returns BoolConstant
	 *     Comparison.GreaterEq_1_0_0_0 returns BoolConstant
	 *     Comparison.LessEq_1_0_1_0 returns BoolConstant
	 *     Comparison.Greater_1_0_2_0 returns BoolConstant
	 *     Comparison.Less_1_0_3_0 returns BoolConstant
	 *     PlusOrMinus returns BoolConstant
	 *     PlusOrMinus.Plus_1_0_0_0 returns BoolConstant
	 *     PlusOrMinus.Minus_1_0_1_0 returns BoolConstant
	 *     MulOrDiv returns BoolConstant
	 *     MulOrDiv.Multiply_1_0_0_0 returns BoolConstant
	 *     MulOrDiv.Divide_1_0_1_0 returns BoolConstant
	 *     Primary returns BoolConstant
	 *     Atomic returns BoolConstant
	 *
	 * Constraint:
	 *     (value='true' | value='false')
	 */
	protected void sequence_Atomic(ISerializationContext context, BoolConstant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns DoubleConstant
	 *     Expression returns DoubleConstant
	 *     Or returns DoubleConstant
	 *     Or.Or_1_0 returns DoubleConstant
	 *     And returns DoubleConstant
	 *     And.And_1_0 returns DoubleConstant
	 *     Equality returns DoubleConstant
	 *     Equality.Equality_1_0_0_0 returns DoubleConstant
	 *     Equality.Inequality_1_0_1_0 returns DoubleConstant
	 *     Comparison returns DoubleConstant
	 *     Comparison.GreaterEq_1_0_0_0 returns DoubleConstant
	 *     Comparison.LessEq_1_0_1_0 returns DoubleConstant
	 *     Comparison.Greater_1_0_2_0 returns DoubleConstant
	 *     Comparison.Less_1_0_3_0 returns DoubleConstant
	 *     PlusOrMinus returns DoubleConstant
	 *     PlusOrMinus.Plus_1_0_0_0 returns DoubleConstant
	 *     PlusOrMinus.Minus_1_0_1_0 returns DoubleConstant
	 *     MulOrDiv returns DoubleConstant
	 *     MulOrDiv.Multiply_1_0_0_0 returns DoubleConstant
	 *     MulOrDiv.Divide_1_0_1_0 returns DoubleConstant
	 *     Primary returns DoubleConstant
	 *     Atomic returns DoubleConstant
	 *
	 * Constraint:
	 *     value=DOUBLE
	 */
	protected void sequence_Atomic(ISerializationContext context, DoubleConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobLANGPackage.Literals.DOUBLE_CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANGPackage.Literals.DOUBLE_CONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getValueDOUBLETerminalRuleCall_5_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns IntConstant
	 *     Expression returns IntConstant
	 *     Or returns IntConstant
	 *     Or.Or_1_0 returns IntConstant
	 *     And returns IntConstant
	 *     And.And_1_0 returns IntConstant
	 *     Equality returns IntConstant
	 *     Equality.Equality_1_0_0_0 returns IntConstant
	 *     Equality.Inequality_1_0_1_0 returns IntConstant
	 *     Comparison returns IntConstant
	 *     Comparison.GreaterEq_1_0_0_0 returns IntConstant
	 *     Comparison.LessEq_1_0_1_0 returns IntConstant
	 *     Comparison.Greater_1_0_2_0 returns IntConstant
	 *     Comparison.Less_1_0_3_0 returns IntConstant
	 *     PlusOrMinus returns IntConstant
	 *     PlusOrMinus.Plus_1_0_0_0 returns IntConstant
	 *     PlusOrMinus.Minus_1_0_1_0 returns IntConstant
	 *     MulOrDiv returns IntConstant
	 *     MulOrDiv.Multiply_1_0_0_0 returns IntConstant
	 *     MulOrDiv.Divide_1_0_1_0 returns IntConstant
	 *     Primary returns IntConstant
	 *     Atomic returns IntConstant
	 *
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_Atomic(ISerializationContext context, IntConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobLANGPackage.Literals.INT_CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANGPackage.Literals.INT_CONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getValueINTTerminalRuleCall_4_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns StringConstant
	 *     Expression returns StringConstant
	 *     Or returns StringConstant
	 *     Or.Or_1_0 returns StringConstant
	 *     And returns StringConstant
	 *     And.And_1_0 returns StringConstant
	 *     Equality returns StringConstant
	 *     Equality.Equality_1_0_0_0 returns StringConstant
	 *     Equality.Inequality_1_0_1_0 returns StringConstant
	 *     Comparison returns StringConstant
	 *     Comparison.GreaterEq_1_0_0_0 returns StringConstant
	 *     Comparison.LessEq_1_0_1_0 returns StringConstant
	 *     Comparison.Greater_1_0_2_0 returns StringConstant
	 *     Comparison.Less_1_0_3_0 returns StringConstant
	 *     PlusOrMinus returns StringConstant
	 *     PlusOrMinus.Plus_1_0_0_0 returns StringConstant
	 *     PlusOrMinus.Minus_1_0_1_0 returns StringConstant
	 *     MulOrDiv returns StringConstant
	 *     MulOrDiv.Multiply_1_0_0_0 returns StringConstant
	 *     MulOrDiv.Divide_1_0_1_0 returns StringConstant
	 *     Primary returns StringConstant
	 *     Atomic returns StringConstant
	 *
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_Atomic(ISerializationContext context, StringConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobLANGPackage.Literals.STRING_CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANGPackage.Literals.STRING_CONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getValueSTRINGTerminalRuleCall_6_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns SymbolRef
	 *     Expression returns SymbolRef
	 *     Or returns SymbolRef
	 *     Or.Or_1_0 returns SymbolRef
	 *     And returns SymbolRef
	 *     And.And_1_0 returns SymbolRef
	 *     Equality returns SymbolRef
	 *     Equality.Equality_1_0_0_0 returns SymbolRef
	 *     Equality.Inequality_1_0_1_0 returns SymbolRef
	 *     Comparison returns SymbolRef
	 *     Comparison.GreaterEq_1_0_0_0 returns SymbolRef
	 *     Comparison.LessEq_1_0_1_0 returns SymbolRef
	 *     Comparison.Greater_1_0_2_0 returns SymbolRef
	 *     Comparison.Less_1_0_3_0 returns SymbolRef
	 *     PlusOrMinus returns SymbolRef
	 *     PlusOrMinus.Plus_1_0_0_0 returns SymbolRef
	 *     PlusOrMinus.Minus_1_0_1_0 returns SymbolRef
	 *     MulOrDiv returns SymbolRef
	 *     MulOrDiv.Multiply_1_0_0_0 returns SymbolRef
	 *     MulOrDiv.Divide_1_0_1_0 returns SymbolRef
	 *     Primary returns SymbolRef
	 *     Atomic returns SymbolRef
	 *
	 * Constraint:
	 *     variable=[Symbol|ID]
	 */
	protected void sequence_Atomic(ISerializationContext context, SymbolRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobLANGPackage.Literals.SYMBOL_REF__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANGPackage.Literals.SYMBOL_REF__VARIABLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getVariableSymbolIDTerminalRuleCall_8_1_0_1(), semanticObject.eGet(RobLANGPackage.Literals.SYMBOL_REF__VARIABLE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Block returns Block
	 *
	 * Constraint:
	 *     statements+=Statement*
	 */
	protected void sequence_Block(ISerializationContext context, Block semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Break
	 *     Break returns Break
	 *
	 * Constraint:
	 *     {Break}
	 */
	protected void sequence_Break(ISerializationContext context, Break semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Greater
	 *     Expression returns Greater
	 *     Or returns Greater
	 *     Or.Or_1_0 returns Greater
	 *     And returns Greater
	 *     And.And_1_0 returns Greater
	 *     Equality returns Greater
	 *     Equality.Equality_1_0_0_0 returns Greater
	 *     Equality.Inequality_1_0_1_0 returns Greater
	 *     Comparison returns Greater
	 *     Comparison.GreaterEq_1_0_0_0 returns Greater
	 *     Comparison.LessEq_1_0_1_0 returns Greater
	 *     Comparison.Greater_1_0_2_0 returns Greater
	 *     Comparison.Less_1_0_3_0 returns Greater
	 *     PlusOrMinus returns Greater
	 *     PlusOrMinus.Plus_1_0_0_0 returns Greater
	 *     PlusOrMinus.Minus_1_0_1_0 returns Greater
	 *     MulOrDiv returns Greater
	 *     MulOrDiv.Multiply_1_0_0_0 returns Greater
	 *     MulOrDiv.Divide_1_0_1_0 returns Greater
	 *     Primary returns Greater
	 *
	 * Constraint:
	 *     (left=Comparison_Greater_1_0_2_0 right=PlusOrMinus)
	 */
	protected void sequence_Comparison(ISerializationContext context, Greater semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobLANGPackage.Literals.GREATER__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANGPackage.Literals.GREATER__LEFT));
			if (transientValues.isValueTransient(semanticObject, RobLANGPackage.Literals.GREATER__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANGPackage.Literals.GREATER__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComparisonAccess().getGreaterLeftAction_1_0_2_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getComparisonAccess().getRightPlusOrMinusParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns GreaterEq
	 *     Expression returns GreaterEq
	 *     Or returns GreaterEq
	 *     Or.Or_1_0 returns GreaterEq
	 *     And returns GreaterEq
	 *     And.And_1_0 returns GreaterEq
	 *     Equality returns GreaterEq
	 *     Equality.Equality_1_0_0_0 returns GreaterEq
	 *     Equality.Inequality_1_0_1_0 returns GreaterEq
	 *     Comparison returns GreaterEq
	 *     Comparison.GreaterEq_1_0_0_0 returns GreaterEq
	 *     Comparison.LessEq_1_0_1_0 returns GreaterEq
	 *     Comparison.Greater_1_0_2_0 returns GreaterEq
	 *     Comparison.Less_1_0_3_0 returns GreaterEq
	 *     PlusOrMinus returns GreaterEq
	 *     PlusOrMinus.Plus_1_0_0_0 returns GreaterEq
	 *     PlusOrMinus.Minus_1_0_1_0 returns GreaterEq
	 *     MulOrDiv returns GreaterEq
	 *     MulOrDiv.Multiply_1_0_0_0 returns GreaterEq
	 *     MulOrDiv.Divide_1_0_1_0 returns GreaterEq
	 *     Primary returns GreaterEq
	 *
	 * Constraint:
	 *     (left=Comparison_GreaterEq_1_0_0_0 right=PlusOrMinus)
	 */
	protected void sequence_Comparison(ISerializationContext context, GreaterEq semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobLANGPackage.Literals.GREATER_EQ__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANGPackage.Literals.GREATER_EQ__LEFT));
			if (transientValues.isValueTransient(semanticObject, RobLANGPackage.Literals.GREATER_EQ__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANGPackage.Literals.GREATER_EQ__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComparisonAccess().getGreaterEqLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getComparisonAccess().getRightPlusOrMinusParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Less
	 *     Expression returns Less
	 *     Or returns Less
	 *     Or.Or_1_0 returns Less
	 *     And returns Less
	 *     And.And_1_0 returns Less
	 *     Equality returns Less
	 *     Equality.Equality_1_0_0_0 returns Less
	 *     Equality.Inequality_1_0_1_0 returns Less
	 *     Comparison returns Less
	 *     Comparison.GreaterEq_1_0_0_0 returns Less
	 *     Comparison.LessEq_1_0_1_0 returns Less
	 *     Comparison.Greater_1_0_2_0 returns Less
	 *     Comparison.Less_1_0_3_0 returns Less
	 *     PlusOrMinus returns Less
	 *     PlusOrMinus.Plus_1_0_0_0 returns Less
	 *     PlusOrMinus.Minus_1_0_1_0 returns Less
	 *     MulOrDiv returns Less
	 *     MulOrDiv.Multiply_1_0_0_0 returns Less
	 *     MulOrDiv.Divide_1_0_1_0 returns Less
	 *     Primary returns Less
	 *
	 * Constraint:
	 *     (left=Comparison_Less_1_0_3_0 right=PlusOrMinus)
	 */
	protected void sequence_Comparison(ISerializationContext context, Less semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobLANGPackage.Literals.LESS__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANGPackage.Literals.LESS__LEFT));
			if (transientValues.isValueTransient(semanticObject, RobLANGPackage.Literals.LESS__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANGPackage.Literals.LESS__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComparisonAccess().getLessLeftAction_1_0_3_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getComparisonAccess().getRightPlusOrMinusParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns LessEq
	 *     Expression returns LessEq
	 *     Or returns LessEq
	 *     Or.Or_1_0 returns LessEq
	 *     And returns LessEq
	 *     And.And_1_0 returns LessEq
	 *     Equality returns LessEq
	 *     Equality.Equality_1_0_0_0 returns LessEq
	 *     Equality.Inequality_1_0_1_0 returns LessEq
	 *     Comparison returns LessEq
	 *     Comparison.GreaterEq_1_0_0_0 returns LessEq
	 *     Comparison.LessEq_1_0_1_0 returns LessEq
	 *     Comparison.Greater_1_0_2_0 returns LessEq
	 *     Comparison.Less_1_0_3_0 returns LessEq
	 *     PlusOrMinus returns LessEq
	 *     PlusOrMinus.Plus_1_0_0_0 returns LessEq
	 *     PlusOrMinus.Minus_1_0_1_0 returns LessEq
	 *     MulOrDiv returns LessEq
	 *     MulOrDiv.Multiply_1_0_0_0 returns LessEq
	 *     MulOrDiv.Divide_1_0_1_0 returns LessEq
	 *     Primary returns LessEq
	 *
	 * Constraint:
	 *     (left=Comparison_LessEq_1_0_1_0 right=PlusOrMinus)
	 */
	protected void sequence_Comparison(ISerializationContext context, LessEq semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobLANGPackage.Literals.LESS_EQ__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANGPackage.Literals.LESS_EQ__LEFT));
			if (transientValues.isValueTransient(semanticObject, RobLANGPackage.Literals.LESS_EQ__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANGPackage.Literals.LESS_EQ__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComparisonAccess().getLessEqLeftAction_1_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getComparisonAccess().getRightPlusOrMinusParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FunDefinition returns ComplexFunction
	 *     ComplexFunction returns ComplexFunction
	 *
	 * Constraint:
	 *     (type=Type name=ID (varNames+=Parameter varNames+=Parameter*)? body=Block)
	 */
	protected void sequence_ComplexFunction(ISerializationContext context, ComplexFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Condition
	 *     Condition returns Condition
	 *
	 * Constraint:
	 *     (expression=Expression ifz=Block elsez=Block?)
	 */
	protected void sequence_Condition(ISerializationContext context, Condition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Equality
	 *     Expression returns Equality
	 *     Or returns Equality
	 *     Or.Or_1_0 returns Equality
	 *     And returns Equality
	 *     And.And_1_0 returns Equality
	 *     Equality returns Equality
	 *     Equality.Equality_1_0_0_0 returns Equality
	 *     Equality.Inequality_1_0_1_0 returns Equality
	 *     Comparison returns Equality
	 *     Comparison.GreaterEq_1_0_0_0 returns Equality
	 *     Comparison.LessEq_1_0_1_0 returns Equality
	 *     Comparison.Greater_1_0_2_0 returns Equality
	 *     Comparison.Less_1_0_3_0 returns Equality
	 *     PlusOrMinus returns Equality
	 *     PlusOrMinus.Plus_1_0_0_0 returns Equality
	 *     PlusOrMinus.Minus_1_0_1_0 returns Equality
	 *     MulOrDiv returns Equality
	 *     MulOrDiv.Multiply_1_0_0_0 returns Equality
	 *     MulOrDiv.Divide_1_0_1_0 returns Equality
	 *     Primary returns Equality
	 *
	 * Constraint:
	 *     (left=Equality_Equality_1_0_0_0 right=Comparison)
	 */
	protected void sequence_Equality(ISerializationContext context, Equality semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobLANGPackage.Literals.EQUALITY__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANGPackage.Literals.EQUALITY__LEFT));
			if (transientValues.isValueTransient(semanticObject, RobLANGPackage.Literals.EQUALITY__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANGPackage.Literals.EQUALITY__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEqualityAccess().getEqualityLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getEqualityAccess().getRightComparisonParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Inequality
	 *     Expression returns Inequality
	 *     Or returns Inequality
	 *     Or.Or_1_0 returns Inequality
	 *     And returns Inequality
	 *     And.And_1_0 returns Inequality
	 *     Equality returns Inequality
	 *     Equality.Equality_1_0_0_0 returns Inequality
	 *     Equality.Inequality_1_0_1_0 returns Inequality
	 *     Comparison returns Inequality
	 *     Comparison.GreaterEq_1_0_0_0 returns Inequality
	 *     Comparison.LessEq_1_0_1_0 returns Inequality
	 *     Comparison.Greater_1_0_2_0 returns Inequality
	 *     Comparison.Less_1_0_3_0 returns Inequality
	 *     PlusOrMinus returns Inequality
	 *     PlusOrMinus.Plus_1_0_0_0 returns Inequality
	 *     PlusOrMinus.Minus_1_0_1_0 returns Inequality
	 *     MulOrDiv returns Inequality
	 *     MulOrDiv.Multiply_1_0_0_0 returns Inequality
	 *     MulOrDiv.Divide_1_0_1_0 returns Inequality
	 *     Primary returns Inequality
	 *
	 * Constraint:
	 *     (left=Equality_Inequality_1_0_1_0 right=Comparison)
	 */
	protected void sequence_Equality(ISerializationContext context, Inequality semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobLANGPackage.Literals.INEQUALITY__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANGPackage.Literals.INEQUALITY__LEFT));
			if (transientValues.isValueTransient(semanticObject, RobLANGPackage.Literals.INEQUALITY__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANGPackage.Literals.INEQUALITY__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEqualityAccess().getInequalityLeftAction_1_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getEqualityAccess().getRightComparisonParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FunCall returns FunCall
	 *     Statement returns FunCall
	 *     Expression returns FunCall
	 *     Or returns FunCall
	 *     Or.Or_1_0 returns FunCall
	 *     And returns FunCall
	 *     And.And_1_0 returns FunCall
	 *     Equality returns FunCall
	 *     Equality.Equality_1_0_0_0 returns FunCall
	 *     Equality.Inequality_1_0_1_0 returns FunCall
	 *     Comparison returns FunCall
	 *     Comparison.GreaterEq_1_0_0_0 returns FunCall
	 *     Comparison.LessEq_1_0_1_0 returns FunCall
	 *     Comparison.Greater_1_0_2_0 returns FunCall
	 *     Comparison.Less_1_0_3_0 returns FunCall
	 *     PlusOrMinus returns FunCall
	 *     PlusOrMinus.Plus_1_0_0_0 returns FunCall
	 *     PlusOrMinus.Minus_1_0_1_0 returns FunCall
	 *     MulOrDiv returns FunCall
	 *     MulOrDiv.Multiply_1_0_0_0 returns FunCall
	 *     MulOrDiv.Divide_1_0_1_0 returns FunCall
	 *     Primary returns FunCall
	 *     Atomic returns FunCall
	 *
	 * Constraint:
	 *     (function=[FunDefinition|ID] (params+=FunParam params+=FunParam*)?)
	 */
	protected void sequence_FunCall(ISerializationContext context, FunCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunParam returns FunParamCapture
	 *
	 * Constraint:
	 *     variable=[Variable|ID]
	 */
	protected void sequence_FunParam(ISerializationContext context, FunParamCapture semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobLANGPackage.Literals.FUN_PARAM_CAPTURE__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANGPackage.Literals.FUN_PARAM_CAPTURE__VARIABLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFunParamAccess().getVariableVariableIDTerminalRuleCall_1_2_0_1(), semanticObject.eGet(RobLANGPackage.Literals.FUN_PARAM_CAPTURE__VARIABLE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FunParam returns FunParamExp
	 *
	 * Constraint:
	 *     expr=Expression
	 */
	protected void sequence_FunParam(ISerializationContext context, FunParamExp semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobLANGPackage.Literals.FUN_PARAM_EXP__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANGPackage.Literals.FUN_PARAM_EXP__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFunParamAccess().getExprExpressionParserRuleCall_0_1_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns GetMaxSpeed
	 *     Effector returns GetMaxSpeed
	 *     Speed returns GetMaxSpeed
	 *     GetMaxSpeed returns GetMaxSpeed
	 *
	 * Constraint:
	 *     {GetMaxSpeed}
	 */
	protected void sequence_GetMaxSpeed(ISerializationContext context, GetMaxSpeed semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunDefinition returns InlineFunction
	 *     InlineFunction returns InlineFunction
	 *
	 * Constraint:
	 *     (type=Type name=ID (varNames+=Parameter varNames+=Parameter*)? expression=Expression)
	 */
	protected void sequence_InlineFunction(ISerializationContext context, InlineFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Loop
	 *     Loop returns Loop
	 *
	 * Constraint:
	 *     (expression=Expression body=Block)
	 */
	protected void sequence_Loop(ISerializationContext context, Loop semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobLANGPackage.Literals.LOOP__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANGPackage.Literals.LOOP__EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, RobLANGPackage.Literals.LOOP__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANGPackage.Literals.LOOP__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLoopAccess().getExpressionExpressionParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.accept(grammarAccess.getLoopAccess().getBodyBlockParserRuleCall_2_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns MathAbs
	 *     Expression returns MathAbs
	 *     Or returns MathAbs
	 *     Or.Or_1_0 returns MathAbs
	 *     And returns MathAbs
	 *     And.And_1_0 returns MathAbs
	 *     Equality returns MathAbs
	 *     Equality.Equality_1_0_0_0 returns MathAbs
	 *     Equality.Inequality_1_0_1_0 returns MathAbs
	 *     Comparison returns MathAbs
	 *     Comparison.GreaterEq_1_0_0_0 returns MathAbs
	 *     Comparison.LessEq_1_0_1_0 returns MathAbs
	 *     Comparison.Greater_1_0_2_0 returns MathAbs
	 *     Comparison.Less_1_0_3_0 returns MathAbs
	 *     PlusOrMinus returns MathAbs
	 *     PlusOrMinus.Plus_1_0_0_0 returns MathAbs
	 *     PlusOrMinus.Minus_1_0_1_0 returns MathAbs
	 *     MulOrDiv returns MathAbs
	 *     MulOrDiv.Multiply_1_0_0_0 returns MathAbs
	 *     MulOrDiv.Divide_1_0_1_0 returns MathAbs
	 *     Primary returns MathAbs
	 *     Atomic returns MathAbs
	 *     MathExpression returns MathAbs
	 *     MathAbs returns MathAbs
	 *
	 * Constraint:
	 *     expression=Expression
	 */
	protected void sequence_MathAbs(ISerializationContext context, MathAbs semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobLANGPackage.Literals.MATH_ABS__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANGPackage.Literals.MATH_ABS__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMathAbsAccess().getExpressionExpressionParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns MathCos
	 *     Expression returns MathCos
	 *     Or returns MathCos
	 *     Or.Or_1_0 returns MathCos
	 *     And returns MathCos
	 *     And.And_1_0 returns MathCos
	 *     Equality returns MathCos
	 *     Equality.Equality_1_0_0_0 returns MathCos
	 *     Equality.Inequality_1_0_1_0 returns MathCos
	 *     Comparison returns MathCos
	 *     Comparison.GreaterEq_1_0_0_0 returns MathCos
	 *     Comparison.LessEq_1_0_1_0 returns MathCos
	 *     Comparison.Greater_1_0_2_0 returns MathCos
	 *     Comparison.Less_1_0_3_0 returns MathCos
	 *     PlusOrMinus returns MathCos
	 *     PlusOrMinus.Plus_1_0_0_0 returns MathCos
	 *     PlusOrMinus.Minus_1_0_1_0 returns MathCos
	 *     MulOrDiv returns MathCos
	 *     MulOrDiv.Multiply_1_0_0_0 returns MathCos
	 *     MulOrDiv.Divide_1_0_1_0 returns MathCos
	 *     Primary returns MathCos
	 *     Atomic returns MathCos
	 *     MathExpression returns MathCos
	 *     MathCos returns MathCos
	 *
	 * Constraint:
	 *     expression=Expression
	 */
	protected void sequence_MathCos(ISerializationContext context, MathCos semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobLANGPackage.Literals.MATH_COS__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANGPackage.Literals.MATH_COS__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMathCosAccess().getExpressionExpressionParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns MathModulo
	 *     Expression returns MathModulo
	 *     Or returns MathModulo
	 *     Or.Or_1_0 returns MathModulo
	 *     And returns MathModulo
	 *     And.And_1_0 returns MathModulo
	 *     Equality returns MathModulo
	 *     Equality.Equality_1_0_0_0 returns MathModulo
	 *     Equality.Inequality_1_0_1_0 returns MathModulo
	 *     Comparison returns MathModulo
	 *     Comparison.GreaterEq_1_0_0_0 returns MathModulo
	 *     Comparison.LessEq_1_0_1_0 returns MathModulo
	 *     Comparison.Greater_1_0_2_0 returns MathModulo
	 *     Comparison.Less_1_0_3_0 returns MathModulo
	 *     PlusOrMinus returns MathModulo
	 *     PlusOrMinus.Plus_1_0_0_0 returns MathModulo
	 *     PlusOrMinus.Minus_1_0_1_0 returns MathModulo
	 *     MulOrDiv returns MathModulo
	 *     MulOrDiv.Multiply_1_0_0_0 returns MathModulo
	 *     MulOrDiv.Divide_1_0_1_0 returns MathModulo
	 *     Primary returns MathModulo
	 *     Atomic returns MathModulo
	 *     MathExpression returns MathModulo
	 *     MathModulo returns MathModulo
	 *
	 * Constraint:
	 *     (lhs=Expression rhs=Expression)
	 */
	protected void sequence_MathModulo(ISerializationContext context, MathModulo semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobLANGPackage.Literals.MATH_MODULO__LHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANGPackage.Literals.MATH_MODULO__LHS));
			if (transientValues.isValueTransient(semanticObject, RobLANGPackage.Literals.MATH_MODULO__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANGPackage.Literals.MATH_MODULO__RHS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMathModuloAccess().getLhsExpressionParserRuleCall_1_0(), semanticObject.getLhs());
		feeder.accept(grammarAccess.getMathModuloAccess().getRhsExpressionParserRuleCall_3_0(), semanticObject.getRhs());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns MathPow
	 *     Expression returns MathPow
	 *     Or returns MathPow
	 *     Or.Or_1_0 returns MathPow
	 *     And returns MathPow
	 *     And.And_1_0 returns MathPow
	 *     Equality returns MathPow
	 *     Equality.Equality_1_0_0_0 returns MathPow
	 *     Equality.Inequality_1_0_1_0 returns MathPow
	 *     Comparison returns MathPow
	 *     Comparison.GreaterEq_1_0_0_0 returns MathPow
	 *     Comparison.LessEq_1_0_1_0 returns MathPow
	 *     Comparison.Greater_1_0_2_0 returns MathPow
	 *     Comparison.Less_1_0_3_0 returns MathPow
	 *     PlusOrMinus returns MathPow
	 *     PlusOrMinus.Plus_1_0_0_0 returns MathPow
	 *     PlusOrMinus.Minus_1_0_1_0 returns MathPow
	 *     MulOrDiv returns MathPow
	 *     MulOrDiv.Multiply_1_0_0_0 returns MathPow
	 *     MulOrDiv.Divide_1_0_1_0 returns MathPow
	 *     Primary returns MathPow
	 *     Atomic returns MathPow
	 *     MathExpression returns MathPow
	 *     MathPow returns MathPow
	 *
	 * Constraint:
	 *     (value=Expression exponant=Expression)
	 */
	protected void sequence_MathPow(ISerializationContext context, MathPow semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobLANGPackage.Literals.MATH_POW__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANGPackage.Literals.MATH_POW__VALUE));
			if (transientValues.isValueTransient(semanticObject, RobLANGPackage.Literals.MATH_POW__EXPONANT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANGPackage.Literals.MATH_POW__EXPONANT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMathPowAccess().getValueExpressionParserRuleCall_1_0(), semanticObject.getValue());
		feeder.accept(grammarAccess.getMathPowAccess().getExponantExpressionParserRuleCall_3_0(), semanticObject.getExponant());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns MathSin
	 *     Expression returns MathSin
	 *     Or returns MathSin
	 *     Or.Or_1_0 returns MathSin
	 *     And returns MathSin
	 *     And.And_1_0 returns MathSin
	 *     Equality returns MathSin
	 *     Equality.Equality_1_0_0_0 returns MathSin
	 *     Equality.Inequality_1_0_1_0 returns MathSin
	 *     Comparison returns MathSin
	 *     Comparison.GreaterEq_1_0_0_0 returns MathSin
	 *     Comparison.LessEq_1_0_1_0 returns MathSin
	 *     Comparison.Greater_1_0_2_0 returns MathSin
	 *     Comparison.Less_1_0_3_0 returns MathSin
	 *     PlusOrMinus returns MathSin
	 *     PlusOrMinus.Plus_1_0_0_0 returns MathSin
	 *     PlusOrMinus.Minus_1_0_1_0 returns MathSin
	 *     MulOrDiv returns MathSin
	 *     MulOrDiv.Multiply_1_0_0_0 returns MathSin
	 *     MulOrDiv.Divide_1_0_1_0 returns MathSin
	 *     Primary returns MathSin
	 *     Atomic returns MathSin
	 *     MathExpression returns MathSin
	 *     MathSin returns MathSin
	 *
	 * Constraint:
	 *     expression=Expression
	 */
	protected void sequence_MathSin(ISerializationContext context, MathSin semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobLANGPackage.Literals.MATH_SIN__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANGPackage.Literals.MATH_SIN__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMathSinAccess().getExpressionExpressionParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns MathSqrt
	 *     Expression returns MathSqrt
	 *     Or returns MathSqrt
	 *     Or.Or_1_0 returns MathSqrt
	 *     And returns MathSqrt
	 *     And.And_1_0 returns MathSqrt
	 *     Equality returns MathSqrt
	 *     Equality.Equality_1_0_0_0 returns MathSqrt
	 *     Equality.Inequality_1_0_1_0 returns MathSqrt
	 *     Comparison returns MathSqrt
	 *     Comparison.GreaterEq_1_0_0_0 returns MathSqrt
	 *     Comparison.LessEq_1_0_1_0 returns MathSqrt
	 *     Comparison.Greater_1_0_2_0 returns MathSqrt
	 *     Comparison.Less_1_0_3_0 returns MathSqrt
	 *     PlusOrMinus returns MathSqrt
	 *     PlusOrMinus.Plus_1_0_0_0 returns MathSqrt
	 *     PlusOrMinus.Minus_1_0_1_0 returns MathSqrt
	 *     MulOrDiv returns MathSqrt
	 *     MulOrDiv.Multiply_1_0_0_0 returns MathSqrt
	 *     MulOrDiv.Divide_1_0_1_0 returns MathSqrt
	 *     Primary returns MathSqrt
	 *     Atomic returns MathSqrt
	 *     MathExpression returns MathSqrt
	 *     MathSqrt returns MathSqrt
	 *
	 * Constraint:
	 *     expression=Expression
	 */
	protected void sequence_MathSqrt(ISerializationContext context, MathSqrt semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobLANGPackage.Literals.MATH_SQRT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANGPackage.Literals.MATH_SQRT__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMathSqrtAccess().getExpressionExpressionParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns MoveBackward
	 *     Effector returns MoveBackward
	 *     Move returns MoveBackward
	 *     MoveBackward returns MoveBackward
	 *
	 * Constraint:
	 *     distance=Expression
	 */
	protected void sequence_MoveBackward(ISerializationContext context, MoveBackward semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobLANGPackage.Literals.MOVE__DISTANCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANGPackage.Literals.MOVE__DISTANCE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMoveBackwardAccess().getDistanceExpressionParserRuleCall_1_0(), semanticObject.getDistance());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns MoveForward
	 *     Effector returns MoveForward
	 *     Move returns MoveForward
	 *     MoveForward returns MoveForward
	 *
	 * Constraint:
	 *     distance=Expression
	 */
	protected void sequence_MoveForward(ISerializationContext context, MoveForward semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobLANGPackage.Literals.MOVE__DISTANCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANGPackage.Literals.MOVE__DISTANCE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMoveForwardAccess().getDistanceExpressionParserRuleCall_1_0(), semanticObject.getDistance());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Divide
	 *     Expression returns Divide
	 *     Or returns Divide
	 *     Or.Or_1_0 returns Divide
	 *     And returns Divide
	 *     And.And_1_0 returns Divide
	 *     Equality returns Divide
	 *     Equality.Equality_1_0_0_0 returns Divide
	 *     Equality.Inequality_1_0_1_0 returns Divide
	 *     Comparison returns Divide
	 *     Comparison.GreaterEq_1_0_0_0 returns Divide
	 *     Comparison.LessEq_1_0_1_0 returns Divide
	 *     Comparison.Greater_1_0_2_0 returns Divide
	 *     Comparison.Less_1_0_3_0 returns Divide
	 *     PlusOrMinus returns Divide
	 *     PlusOrMinus.Plus_1_0_0_0 returns Divide
	 *     PlusOrMinus.Minus_1_0_1_0 returns Divide
	 *     MulOrDiv returns Divide
	 *     MulOrDiv.Multiply_1_0_0_0 returns Divide
	 *     MulOrDiv.Divide_1_0_1_0 returns Divide
	 *     Primary returns Divide
	 *
	 * Constraint:
	 *     (left=MulOrDiv_Divide_1_0_1_0 right=Primary)
	 */
	protected void sequence_MulOrDiv(ISerializationContext context, Divide semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobLANGPackage.Literals.DIVIDE__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANGPackage.Literals.DIVIDE__LEFT));
			if (transientValues.isValueTransient(semanticObject, RobLANGPackage.Literals.DIVIDE__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANGPackage.Literals.DIVIDE__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMulOrDivAccess().getDivideLeftAction_1_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMulOrDivAccess().getRightPrimaryParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Multiply
	 *     Expression returns Multiply
	 *     Or returns Multiply
	 *     Or.Or_1_0 returns Multiply
	 *     And returns Multiply
	 *     And.And_1_0 returns Multiply
	 *     Equality returns Multiply
	 *     Equality.Equality_1_0_0_0 returns Multiply
	 *     Equality.Inequality_1_0_1_0 returns Multiply
	 *     Comparison returns Multiply
	 *     Comparison.GreaterEq_1_0_0_0 returns Multiply
	 *     Comparison.LessEq_1_0_1_0 returns Multiply
	 *     Comparison.Greater_1_0_2_0 returns Multiply
	 *     Comparison.Less_1_0_3_0 returns Multiply
	 *     PlusOrMinus returns Multiply
	 *     PlusOrMinus.Plus_1_0_0_0 returns Multiply
	 *     PlusOrMinus.Minus_1_0_1_0 returns Multiply
	 *     MulOrDiv returns Multiply
	 *     MulOrDiv.Multiply_1_0_0_0 returns Multiply
	 *     MulOrDiv.Divide_1_0_1_0 returns Multiply
	 *     Primary returns Multiply
	 *
	 * Constraint:
	 *     (left=MulOrDiv_Multiply_1_0_0_0 right=Primary)
	 */
	protected void sequence_MulOrDiv(ISerializationContext context, Multiply semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobLANGPackage.Literals.MULTIPLY__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANGPackage.Literals.MULTIPLY__LEFT));
			if (transientValues.isValueTransient(semanticObject, RobLANGPackage.Literals.MULTIPLY__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANGPackage.Literals.MULTIPLY__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMulOrDivAccess().getMultiplyLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMulOrDivAccess().getRightPrimaryParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Or
	 *     Expression returns Or
	 *     Or returns Or
	 *     Or.Or_1_0 returns Or
	 *     And returns Or
	 *     And.And_1_0 returns Or
	 *     Equality returns Or
	 *     Equality.Equality_1_0_0_0 returns Or
	 *     Equality.Inequality_1_0_1_0 returns Or
	 *     Comparison returns Or
	 *     Comparison.GreaterEq_1_0_0_0 returns Or
	 *     Comparison.LessEq_1_0_1_0 returns Or
	 *     Comparison.Greater_1_0_2_0 returns Or
	 *     Comparison.Less_1_0_3_0 returns Or
	 *     PlusOrMinus returns Or
	 *     PlusOrMinus.Plus_1_0_0_0 returns Or
	 *     PlusOrMinus.Minus_1_0_1_0 returns Or
	 *     MulOrDiv returns Or
	 *     MulOrDiv.Multiply_1_0_0_0 returns Or
	 *     MulOrDiv.Divide_1_0_1_0 returns Or
	 *     Primary returns Or
	 *
	 * Constraint:
	 *     (left=Or_Or_1_0 right=And)
	 */
	protected void sequence_Or(ISerializationContext context, Or semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobLANGPackage.Literals.OR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANGPackage.Literals.OR__LEFT));
			if (transientValues.isValueTransient(semanticObject, RobLANGPackage.Literals.OR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANGPackage.Literals.OR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOrAccess().getOrLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getOrAccess().getRightAndParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Symbol returns Parameter
	 *     Parameter returns Parameter
	 *
	 * Constraint:
	 *     (type=Type name=ID)
	 */
	protected void sequence_Parameter(ISerializationContext context, fr.gwendal_jouneaux.rob_lang.robLANG.Parameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobLANGPackage.Literals.SYMBOL__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANGPackage.Literals.SYMBOL__TYPE));
			if (transientValues.isValueTransient(semanticObject, RobLANGPackage.Literals.SYMBOL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANGPackage.Literals.SYMBOL__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParameterAccess().getTypeTypeParserRuleCall_0_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getParameterAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Minus
	 *     Expression returns Minus
	 *     Or returns Minus
	 *     Or.Or_1_0 returns Minus
	 *     And returns Minus
	 *     And.And_1_0 returns Minus
	 *     Equality returns Minus
	 *     Equality.Equality_1_0_0_0 returns Minus
	 *     Equality.Inequality_1_0_1_0 returns Minus
	 *     Comparison returns Minus
	 *     Comparison.GreaterEq_1_0_0_0 returns Minus
	 *     Comparison.LessEq_1_0_1_0 returns Minus
	 *     Comparison.Greater_1_0_2_0 returns Minus
	 *     Comparison.Less_1_0_3_0 returns Minus
	 *     PlusOrMinus returns Minus
	 *     PlusOrMinus.Plus_1_0_0_0 returns Minus
	 *     PlusOrMinus.Minus_1_0_1_0 returns Minus
	 *     MulOrDiv returns Minus
	 *     MulOrDiv.Multiply_1_0_0_0 returns Minus
	 *     MulOrDiv.Divide_1_0_1_0 returns Minus
	 *     Primary returns Minus
	 *
	 * Constraint:
	 *     (left=PlusOrMinus_Minus_1_0_1_0 right=MulOrDiv)
	 */
	protected void sequence_PlusOrMinus(ISerializationContext context, Minus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobLANGPackage.Literals.MINUS__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANGPackage.Literals.MINUS__LEFT));
			if (transientValues.isValueTransient(semanticObject, RobLANGPackage.Literals.MINUS__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANGPackage.Literals.MINUS__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPlusOrMinusAccess().getMinusLeftAction_1_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getPlusOrMinusAccess().getRightMulOrDivParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Plus
	 *     Expression returns Plus
	 *     Or returns Plus
	 *     Or.Or_1_0 returns Plus
	 *     And returns Plus
	 *     And.And_1_0 returns Plus
	 *     Equality returns Plus
	 *     Equality.Equality_1_0_0_0 returns Plus
	 *     Equality.Inequality_1_0_1_0 returns Plus
	 *     Comparison returns Plus
	 *     Comparison.GreaterEq_1_0_0_0 returns Plus
	 *     Comparison.LessEq_1_0_1_0 returns Plus
	 *     Comparison.Greater_1_0_2_0 returns Plus
	 *     Comparison.Less_1_0_3_0 returns Plus
	 *     PlusOrMinus returns Plus
	 *     PlusOrMinus.Plus_1_0_0_0 returns Plus
	 *     PlusOrMinus.Minus_1_0_1_0 returns Plus
	 *     MulOrDiv returns Plus
	 *     MulOrDiv.Multiply_1_0_0_0 returns Plus
	 *     MulOrDiv.Divide_1_0_1_0 returns Plus
	 *     Primary returns Plus
	 *
	 * Constraint:
	 *     (left=PlusOrMinus_Plus_1_0_0_0 right=MulOrDiv)
	 */
	protected void sequence_PlusOrMinus(ISerializationContext context, Plus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobLANGPackage.Literals.PLUS__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANGPackage.Literals.PLUS__LEFT));
			if (transientValues.isValueTransient(semanticObject, RobLANGPackage.Literals.PLUS__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANGPackage.Literals.PLUS__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPlusOrMinusAccess().getPlusLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getPlusOrMinusAccess().getRightMulOrDivParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Not
	 *     Expression returns Not
	 *     Or returns Not
	 *     Or.Or_1_0 returns Not
	 *     And returns Not
	 *     And.And_1_0 returns Not
	 *     Equality returns Not
	 *     Equality.Equality_1_0_0_0 returns Not
	 *     Equality.Inequality_1_0_1_0 returns Not
	 *     Comparison returns Not
	 *     Comparison.GreaterEq_1_0_0_0 returns Not
	 *     Comparison.LessEq_1_0_1_0 returns Not
	 *     Comparison.Greater_1_0_2_0 returns Not
	 *     Comparison.Less_1_0_3_0 returns Not
	 *     PlusOrMinus returns Not
	 *     PlusOrMinus.Plus_1_0_0_0 returns Not
	 *     PlusOrMinus.Minus_1_0_1_0 returns Not
	 *     MulOrDiv returns Not
	 *     MulOrDiv.Multiply_1_0_0_0 returns Not
	 *     MulOrDiv.Divide_1_0_1_0 returns Not
	 *     Primary returns Not
	 *
	 * Constraint:
	 *     expression=Primary
	 */
	protected void sequence_Primary(ISerializationContext context, Not semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobLANGPackage.Literals.NOT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANGPackage.Literals.NOT__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimaryAccess().getExpressionPrimaryParserRuleCall_1_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns PrintExpression
	 *     PrintExpression returns PrintExpression
	 *
	 * Constraint:
	 *     expression=Expression
	 */
	protected void sequence_PrintExpression(ISerializationContext context, PrintExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobLANGPackage.Literals.PRINT_EXPRESSION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANGPackage.Literals.PRINT_EXPRESSION__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrintExpressionAccess().getExpressionExpressionParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Return
	 *     Return returns Return
	 *
	 * Constraint:
	 *     expression=Expression
	 */
	protected void sequence_Return(ISerializationContext context, Return semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobLANGPackage.Literals.RETURN__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANGPackage.Literals.RETURN__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getReturnAccess().getExpressionExpressionParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Robot returns Robot
	 *
	 * Constraint:
	 *     (name=ID functions+=FunDefinition+)
	 */
	protected void sequence_Robot(ISerializationContext context, Robot semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns SenseBattery
	 *     Expression returns SenseBattery
	 *     Or returns SenseBattery
	 *     Or.Or_1_0 returns SenseBattery
	 *     And returns SenseBattery
	 *     And.And_1_0 returns SenseBattery
	 *     Equality returns SenseBattery
	 *     Equality.Equality_1_0_0_0 returns SenseBattery
	 *     Equality.Inequality_1_0_1_0 returns SenseBattery
	 *     Comparison returns SenseBattery
	 *     Comparison.GreaterEq_1_0_0_0 returns SenseBattery
	 *     Comparison.LessEq_1_0_1_0 returns SenseBattery
	 *     Comparison.Greater_1_0_2_0 returns SenseBattery
	 *     Comparison.Less_1_0_3_0 returns SenseBattery
	 *     PlusOrMinus returns SenseBattery
	 *     PlusOrMinus.Plus_1_0_0_0 returns SenseBattery
	 *     PlusOrMinus.Minus_1_0_1_0 returns SenseBattery
	 *     MulOrDiv returns SenseBattery
	 *     MulOrDiv.Multiply_1_0_0_0 returns SenseBattery
	 *     MulOrDiv.Divide_1_0_1_0 returns SenseBattery
	 *     Primary returns SenseBattery
	 *     Atomic returns SenseBattery
	 *     Sensor returns SenseBattery
	 *     SenseBattery returns SenseBattery
	 *
	 * Constraint:
	 *     {SenseBattery}
	 */
	protected void sequence_SenseBattery(ISerializationContext context, SenseBattery semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns SenseCompass
	 *     Expression returns SenseCompass
	 *     Or returns SenseCompass
	 *     Or.Or_1_0 returns SenseCompass
	 *     And returns SenseCompass
	 *     And.And_1_0 returns SenseCompass
	 *     Equality returns SenseCompass
	 *     Equality.Equality_1_0_0_0 returns SenseCompass
	 *     Equality.Inequality_1_0_1_0 returns SenseCompass
	 *     Comparison returns SenseCompass
	 *     Comparison.GreaterEq_1_0_0_0 returns SenseCompass
	 *     Comparison.LessEq_1_0_1_0 returns SenseCompass
	 *     Comparison.Greater_1_0_2_0 returns SenseCompass
	 *     Comparison.Less_1_0_3_0 returns SenseCompass
	 *     PlusOrMinus returns SenseCompass
	 *     PlusOrMinus.Plus_1_0_0_0 returns SenseCompass
	 *     PlusOrMinus.Minus_1_0_1_0 returns SenseCompass
	 *     MulOrDiv returns SenseCompass
	 *     MulOrDiv.Multiply_1_0_0_0 returns SenseCompass
	 *     MulOrDiv.Divide_1_0_1_0 returns SenseCompass
	 *     Primary returns SenseCompass
	 *     Atomic returns SenseCompass
	 *     Sensor returns SenseCompass
	 *     SenseCompass returns SenseCompass
	 *
	 * Constraint:
	 *     {SenseCompass}
	 */
	protected void sequence_SenseCompass(ISerializationContext context, SenseCompass semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns SenseDistance
	 *     Expression returns SenseDistance
	 *     Or returns SenseDistance
	 *     Or.Or_1_0 returns SenseDistance
	 *     And returns SenseDistance
	 *     And.And_1_0 returns SenseDistance
	 *     Equality returns SenseDistance
	 *     Equality.Equality_1_0_0_0 returns SenseDistance
	 *     Equality.Inequality_1_0_1_0 returns SenseDistance
	 *     Comparison returns SenseDistance
	 *     Comparison.GreaterEq_1_0_0_0 returns SenseDistance
	 *     Comparison.LessEq_1_0_1_0 returns SenseDistance
	 *     Comparison.Greater_1_0_2_0 returns SenseDistance
	 *     Comparison.Less_1_0_3_0 returns SenseDistance
	 *     PlusOrMinus returns SenseDistance
	 *     PlusOrMinus.Plus_1_0_0_0 returns SenseDistance
	 *     PlusOrMinus.Minus_1_0_1_0 returns SenseDistance
	 *     MulOrDiv returns SenseDistance
	 *     MulOrDiv.Multiply_1_0_0_0 returns SenseDistance
	 *     MulOrDiv.Divide_1_0_1_0 returns SenseDistance
	 *     Primary returns SenseDistance
	 *     Atomic returns SenseDistance
	 *     Sensor returns SenseDistance
	 *     SenseDistance returns SenseDistance
	 *
	 * Constraint:
	 *     sensorIndex=INT
	 */
	protected void sequence_SenseDistance(ISerializationContext context, SenseDistance semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobLANGPackage.Literals.SENSE_DISTANCE__SENSOR_INDEX) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANGPackage.Literals.SENSE_DISTANCE__SENSOR_INDEX));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSenseDistanceAccess().getSensorIndexINTTerminalRuleCall_3_0(), semanticObject.getSensorIndex());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns SensePosition
	 *     Expression returns SensePosition
	 *     Or returns SensePosition
	 *     Or.Or_1_0 returns SensePosition
	 *     And returns SensePosition
	 *     And.And_1_0 returns SensePosition
	 *     Equality returns SensePosition
	 *     Equality.Equality_1_0_0_0 returns SensePosition
	 *     Equality.Inequality_1_0_1_0 returns SensePosition
	 *     Comparison returns SensePosition
	 *     Comparison.GreaterEq_1_0_0_0 returns SensePosition
	 *     Comparison.LessEq_1_0_1_0 returns SensePosition
	 *     Comparison.Greater_1_0_2_0 returns SensePosition
	 *     Comparison.Less_1_0_3_0 returns SensePosition
	 *     PlusOrMinus returns SensePosition
	 *     PlusOrMinus.Plus_1_0_0_0 returns SensePosition
	 *     PlusOrMinus.Minus_1_0_1_0 returns SensePosition
	 *     MulOrDiv returns SensePosition
	 *     MulOrDiv.Multiply_1_0_0_0 returns SensePosition
	 *     MulOrDiv.Divide_1_0_1_0 returns SensePosition
	 *     Primary returns SensePosition
	 *     Atomic returns SensePosition
	 *     Sensor returns SensePosition
	 *     SensePosition returns SensePosition
	 *
	 * Constraint:
	 *     {SensePosition}
	 */
	protected void sequence_SensePosition(ISerializationContext context, SensePosition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns SenseTime
	 *     Expression returns SenseTime
	 *     Or returns SenseTime
	 *     Or.Or_1_0 returns SenseTime
	 *     And returns SenseTime
	 *     And.And_1_0 returns SenseTime
	 *     Equality returns SenseTime
	 *     Equality.Equality_1_0_0_0 returns SenseTime
	 *     Equality.Inequality_1_0_1_0 returns SenseTime
	 *     Comparison returns SenseTime
	 *     Comparison.GreaterEq_1_0_0_0 returns SenseTime
	 *     Comparison.LessEq_1_0_1_0 returns SenseTime
	 *     Comparison.Greater_1_0_2_0 returns SenseTime
	 *     Comparison.Less_1_0_3_0 returns SenseTime
	 *     PlusOrMinus returns SenseTime
	 *     PlusOrMinus.Plus_1_0_0_0 returns SenseTime
	 *     PlusOrMinus.Minus_1_0_1_0 returns SenseTime
	 *     MulOrDiv returns SenseTime
	 *     MulOrDiv.Multiply_1_0_0_0 returns SenseTime
	 *     MulOrDiv.Divide_1_0_1_0 returns SenseTime
	 *     Primary returns SenseTime
	 *     Atomic returns SenseTime
	 *     Sensor returns SenseTime
	 *     SenseTime returns SenseTime
	 *
	 * Constraint:
	 *     {SenseTime}
	 */
	protected void sequence_SenseTime(ISerializationContext context, SenseTime semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns SetNominalSpeed
	 *     Effector returns SetNominalSpeed
	 *     Speed returns SetNominalSpeed
	 *     SetNominalSpeed returns SetNominalSpeed
	 *
	 * Constraint:
	 *     speed=Expression
	 */
	protected void sequence_SetNominalSpeed(ISerializationContext context, SetNominalSpeed semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobLANGPackage.Literals.SET_NOMINAL_SPEED__SPEED) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANGPackage.Literals.SET_NOMINAL_SPEED__SPEED));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSetNominalSpeedAccess().getSpeedExpressionParserRuleCall_2_0(), semanticObject.getSpeed());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns TurnLeft
	 *     Effector returns TurnLeft
	 *     Turn returns TurnLeft
	 *     TurnLeft returns TurnLeft
	 *
	 * Constraint:
	 *     angle=Expression
	 */
	protected void sequence_TurnLeft(ISerializationContext context, TurnLeft semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobLANGPackage.Literals.TURN__ANGLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANGPackage.Literals.TURN__ANGLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTurnLeftAccess().getAngleExpressionParserRuleCall_1_0(), semanticObject.getAngle());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns TurnRight
	 *     Effector returns TurnRight
	 *     Turn returns TurnRight
	 *     TurnRight returns TurnRight
	 *
	 * Constraint:
	 *     angle=Expression
	 */
	protected void sequence_TurnRight(ISerializationContext context, TurnRight semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobLANGPackage.Literals.TURN__ANGLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANGPackage.Literals.TURN__ANGLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTurnRightAccess().getAngleExpressionParserRuleCall_1_0(), semanticObject.getAngle());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Type returns Type
	 *
	 * Constraint:
	 *     (type=BasicType dimension=INT?)
	 */
	protected void sequence_Type(ISerializationContext context, Type semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Symbol returns Variable
	 *     Statement returns Variable
	 *     Variable returns Variable
	 *
	 * Constraint:
	 *     (type=Type name=ID expression=Expression)
	 */
	protected void sequence_Variable(ISerializationContext context, Variable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobLANGPackage.Literals.SYMBOL__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANGPackage.Literals.SYMBOL__TYPE));
			if (transientValues.isValueTransient(semanticObject, RobLANGPackage.Literals.SYMBOL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANGPackage.Literals.SYMBOL__NAME));
			if (transientValues.isValueTransient(semanticObject, RobLANGPackage.Literals.VARIABLE__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobLANGPackage.Literals.VARIABLE__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableAccess().getTypeTypeParserRuleCall_1_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getVariableAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getVariableAccess().getExpressionExpressionParserRuleCall_4_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
}
